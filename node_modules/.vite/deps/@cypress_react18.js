import {
  require_client,
  require_react_dom
} from "./chunk-D773ODSN.js";
import {
  require_react
} from "./chunk-NTFE6N72.js";
import {
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/@cypress/react18/dist/cypress-react.esm-bundler.js
var import_client = __toESM(require_client());
var React = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var cachedDisplayNames = /* @__PURE__ */ new WeakMap();
function getDisplayName(type, fallbackName = "Unknown") {
  const nameFromCache = cachedDisplayNames.get(type);
  if (nameFromCache != null) {
    return nameFromCache;
  }
  let displayName = null;
  if (typeof type.displayName === "string") {
    displayName = type.displayName;
  }
  if (!displayName) {
    displayName = type.name || fallbackName;
  }
  const match = displayName.match(/^(.*) \[from (.*)\]$/);
  if (match) {
    const componentName = match[1];
    const moduleName = match[2];
    if (componentName && moduleName) {
      if (moduleName === componentName || moduleName.startsWith(`${componentName}.`)) {
        displayName = componentName;
      }
    }
  }
  try {
    cachedDisplayNames.set(type, displayName);
  } catch (e) {
  }
  return displayName;
}
var ROOT_SELECTOR = "[data-cy-root]";
var getContainerEl = () => {
  const el = document.querySelector(ROOT_SELECTOR);
  if (el) {
    return el;
  }
  throw Error(`No element found that matches selector ${ROOT_SELECTOR}. Please add a root element with data-cy-root attribute to your "component-index.html" file so that Cypress can attach your component to the DOM.`);
};
function cleanupStyles() {
  const styles = document.body.querySelectorAll("[data-cy=injected-style-tag]");
  styles.forEach((styleElement) => {
    if (styleElement.parentElement) {
      styleElement.parentElement.removeChild(styleElement);
    }
  });
  const links = document.body.querySelectorAll("[data-cy=injected-stylesheet]");
  links.forEach((link) => {
    if (link.parentElement) {
      link.parentElement.removeChild(link);
    }
  });
}
function insertStylesheets(stylesheets, document2, el) {
  stylesheets.forEach((href) => {
    const link = document2.createElement("link");
    link.type = "text/css";
    link.rel = "stylesheet";
    link.href = href;
    link.dataset.cy = "injected-stylesheet";
    document2.body.insertBefore(link, el);
  });
}
function insertStyles(styles, document2, el) {
  styles.forEach((style) => {
    const styleElement = document2.createElement("style");
    styleElement.dataset.cy = "injected-style-tag";
    styleElement.appendChild(document2.createTextNode(style));
    document2.body.insertBefore(styleElement, el);
  });
}
function insertSingleCssFile(cssFilename, document2, el, log) {
  return cy.readFile(cssFilename, { log }).then((css) => {
    const style = document2.createElement("style");
    style.appendChild(document2.createTextNode(css));
    document2.body.insertBefore(style, el);
  });
}
function insertLocalCssFiles(cssFilenames, document2, el, log) {
  return Cypress.Promise.mapSeries(cssFilenames, (cssFilename) => {
    return insertSingleCssFile(cssFilename, document2, el, log);
  });
}
var injectStylesBeforeElement = (options, document2, el) => {
  if (!el)
    return;
  let stylesheets = [];
  if (typeof options.stylesheet === "string") {
    stylesheets.push(options.stylesheet);
  } else if (Array.isArray(options.stylesheet)) {
    stylesheets = stylesheets.concat(options.stylesheet);
  }
  if (typeof options.stylesheets === "string") {
    options.stylesheets = [options.stylesheets];
  }
  if (options.stylesheets) {
    stylesheets = stylesheets.concat(options.stylesheets);
  }
  insertStylesheets(stylesheets, document2, el);
  let styles = [];
  if (typeof options.style === "string") {
    styles.push(options.style);
  } else if (Array.isArray(options.style)) {
    styles = styles.concat(options.style);
  }
  if (typeof options.styles === "string") {
    styles.push(options.styles);
  } else if (Array.isArray(options.styles)) {
    styles = styles.concat(options.styles);
  }
  insertStyles(styles, document2, el);
  let cssFiles = [];
  if (typeof options.cssFile === "string") {
    cssFiles.push(options.cssFile);
  } else if (Array.isArray(options.cssFile)) {
    cssFiles = cssFiles.concat(options.cssFile);
  }
  if (typeof options.cssFiles === "string") {
    cssFiles.push(options.cssFiles);
  } else if (Array.isArray(options.cssFiles)) {
    cssFiles = cssFiles.concat(options.cssFiles);
  }
  return insertLocalCssFiles(cssFiles, document2, el, options.log);
};
function setupHooks(optionalCallback) {
  if (Cypress.testingType !== "component") {
    return;
  }
  Cypress.Commands.overwrite("visit", () => {
    throw new Error("cy.visit from a component spec is not allowed");
  });
  Cypress.on("test:before:run", () => {
    optionalCallback === null || optionalCallback === void 0 ? void 0 : optionalCallback();
    cleanupStyles();
  });
}
var injectStyles = (options) => {
  return () => {
    const el = getContainerEl();
    return injectStylesBeforeElement(options, document, el);
  };
};
var mountCleanup;
var makeMountFn = (type, jsx, options = {}, rerenderKey, internalMountOptions) => {
  if (!internalMountOptions) {
    throw Error("internalMountOptions must be provided with `render` and `reactDom` parameters");
  }
  mountCleanup = internalMountOptions.cleanup;
  const componentName = getDisplayName(jsx.type, options.alias);
  const displayName = options.alias || componentName;
  const jsxComponentName = `<${componentName} ... />`;
  const message = options.alias ? `${jsxComponentName} as "${options.alias}"` : jsxComponentName;
  return cy.then(injectStyles(options)).then(() => {
    var _a, _b, _c;
    const reactDomToUse = internalMountOptions.reactDom;
    const el = getContainerEl();
    if (!el) {
      throw new Error([
        `[@cypress/react] \u{1F525} Hmm, cannot find root element to mount the component. Searched for ${ROOT_SELECTOR}`
      ].join(" "));
    }
    const key = rerenderKey !== null && rerenderKey !== void 0 ? rerenderKey : (((_c = (_b = (_a = Cypress === null || Cypress === void 0 ? void 0 : Cypress.mocha) === null || _a === void 0 ? void 0 : _a.getRunner()) === null || _b === void 0 ? void 0 : _b.test) === null || _c === void 0 ? void 0 : _c.title) || "") + Math.random();
    const props = {
      key
    };
    const reactComponent = React.createElement(options.strict ? React.StrictMode : React.Fragment, props, jsx);
    const userComponent = reactComponent.props.children;
    internalMountOptions.render(reactComponent, el, reactDomToUse);
    if (options.log !== false) {
      Cypress.log({
        name: type,
        type: "parent",
        message: [message],
        $el: el.children.item(0),
        consoleProps: () => {
          return {
            props: jsx.props,
            description: type === "mount" ? "Mounts React component" : "Rerenders mounted React component",
            home: "https://github.com/cypress-io/cypress"
          };
        }
      }).snapshot("mounted").end();
    }
    return cy.wrap(userComponent, { log: false }).as(displayName).then(() => {
      return cy.wrap({
        component: userComponent,
        rerender: (newComponent) => makeMountFn("rerender", newComponent, options, key, internalMountOptions),
        unmount: internalMountOptions.unmount
      }, { log: false });
    }).wait(0, { log: false });
  });
};
var makeUnmountFn = (options) => {
  return cy.then(() => {
    var _a;
    const wasUnmounted = mountCleanup === null || mountCleanup === void 0 ? void 0 : mountCleanup();
    if (wasUnmounted && options.log) {
      Cypress.log({
        name: "unmount",
        type: "parent",
        message: [(_a = options.boundComponentMessage) !== null && _a !== void 0 ? _a : "Unmounted component"],
        consoleProps: () => {
          return {
            description: "Unmounts React component",
            parent: getContainerEl().parentNode,
            home: "https://github.com/cypress-io/cypress"
          };
        }
      });
    }
  });
};
var preMountCleanup = () => {
  mountCleanup === null || mountCleanup === void 0 ? void 0 : mountCleanup();
};
setupHooks(preMountCleanup);
var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug;
var SEMVER_SPEC_VERSION = "2.0.0";
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
function createCommonjsModule(fn) {
  var module = { exports: {} };
  return fn(module, module.exports), module.exports;
}
createCommonjsModule(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  exports = module.exports = {};
  const re = exports.re = [];
  const src = exports.src = [];
  const t = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug_1(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var root;
var cleanup = () => {
  if (root) {
    root.unmount();
    return true;
  }
  return false;
};
function mount(jsx, options = {}, rerenderKey) {
  const internalOptions = {
    reactDom: import_client.default,
    render: (reactComponent, el) => {
      root = import_client.default.createRoot(el);
      return root.render(reactComponent);
    },
    unmount,
    cleanup
  };
  return makeMountFn("mount", jsx, Object.assign({ ReactDom: import_client.default }, options), rerenderKey, internalOptions);
}
function unmount(options = { log: true }) {
  return makeUnmountFn(options);
}
export {
  mount,
  unmount
};
//# sourceMappingURL=@cypress_react18.js.map
